\chapter{Introduction}
\section{Interesting Quantum Programming Languages}
Qiskit, which is the most prominent and based around Python.
q1tsim, which is based on Rust and the docmentation is mostly in Rust
but apparently can be used in Python as well.
\section{Qubit-Basics}
The two orthogonal z-basis states of a qubit are defined as $\ket{0}$
and $\ket{1}$. When we talk about the qubit basis states we implicitly
refer to the z-basis as the computational basis states.\\
The two orthogonal x-basis states are
\begin{equation}
  \label{eq:4}
  \ket{+} = \frac{1}{\sqrt{2}}\left(\ket{0}+\ket{1}\right) \qquad
  \ket{-} = \frac{1}{\sqrt{2}}\left(\ket{0}-\ket{1}\right).
\end{equation}

The two orthogonal y-basis states are
\begin{equation}
  \label{eq:4}
  \ket{R} = \frac{1}{\sqrt{2}}\left(\ket{0}+i\ket{1}\right) \qquad
  \ket{L} = \frac{1}{\sqrt{2}}\left(\ket{0}-i\ket{1}\right).
\end{equation}
\section{Eigen, Eigen, Eigen}
Quantum mechanics uses the concept of eiegenvalue and eigenvector and
extends it to linear operators. An operator is a thing that transforms
a function into antoher function - analogously to how a matrix
transforms a vector into another vector. An "eigenfunction" of some
linear Operator $A$, is then a function that satisfies
\begin{equation}
  \label{eq:5}
  A \Psi = \lambda \Psi,
\end{equation}
where $\Psi$ is some function, $A$ an operator, and $\lambda$ some
real value.
Differentiation is a linear operator. Define the differential Operator
\begin{equation}
  \label{eq:6}
  \hat{D} = \frac{\partial}{\partial x}.
\end{equation}
What is its eigenfunction? That is,
\begin{equation}
  \label{eq:7}
  D \Psi = \lambda \Psi.
\end{equation}
If you write the operator out, you have
\begin{equation}
  \label{eq:8}
  \frac{\partial \Psi}{\partial x} = \lambda \Psi.
\end{equation}
The solution to this differential equation is
\begin{equation}
  \label{eq:9}
  \Psi = e^{\lambda x}.
\end{equation}
So any such exponential function is an eigenfunction of $\hat{D}$.
An example related to quantum mechanics specifically, you have the
time-independant Schr√∂dinger equation
\begin{equation}
  \label{eq:10}
  H \Psi = E \Psi.
\end{equation}
The energies here are the eigenvalues, and the energy states are
described by the corresponding eigenfunctions, hence eigenstates.
\section{Quantum Fourier Transform}
The quantum Fourier transform (QFT) transforms between two bases, the
computational (Z) basis, and the Fourier basis. It can be written as a
mapping
\begin{equation}
  \label{eq:2}
  \ket{x} \mapsto \frac{1}{\sqrt{N}}\sum^{N-1}_{y=0}\omega^{xy}_{N}\ket{y}
\end{equation}
or as an unitary matrix
\begin{equation}
  \label{eq:3}
  U_{\text{QFT}}= \frac{1}{\sqrt{N}}\sum^{N-1}_{x=0}\sum^{N-1}_{y=0}\omega^{xy}_N\ket{y}\bra{x}.
\end{equation}
The H-gate is the
signle-qubit QFT, and it transfroms between the Z-basis states
$\ket{0}$ and $\ket{1}$ to the X-basis states $\ket{+}$ and
$\ket{-}$. In the same way, all multi-qubit states in the
computational basis have corresponding states in the Fourier
basis. The QFT is simply the function that transforms between these
bases.
\begin{align}
  \label{eq:1}
  \ket{\text{State in Computational Basis}}
  &\overset{QFT}{\longrightarrow} \ket{\text{State in Fourier
    Basis}}\\
  QFT\ket{x} &= \ket{\tilde{x}}.\\
\end{align}

In the computational basis, we store numbers in binary, just like a
Johnson Counter.
The first qubit has the highest frequency and changes every iteration,
while the last one has the lowest frequency.
In the Fourier basis, we store numbers using different rotations
around the Z-axis.
To encode the state $\ket{\tilde{5}}$ on 4 qubits, we rotate the
leftmost qubit by $\frac{5}{2^n} = \frac{5}{2^4} = \frac{5}{16}\times
2\pi \text{radians}$. For the next qubit the numerator is doubled,
thus $\frac{10}{16} \times 2\pi$.
This leads to the result, that now the first qubit has the lowest
frequency, while the fourth qubit has the quickest. Note that in the
Fourier basis, we are no longer counting binarily.
\begin{center}
    \begin{tikzpicture}
        \node[scale=1.0] {
          \begin{quantikz}
            \lstick{$\ket{q_\text{ion}}$} & \qw & \qw & \qw & \ctrl{1}
            & \gate{R_y(-2\sqrt{\kappa_s}\lambda)} & \ctrl{1} \\
            \lstick{$\ket{q_\text{laser}}$} & \qw & \gate{R_y(2\abs{\alpha}\lambda)} &
            \gate{R_z(-\omega l \lambda^2)} & \targ{} & \ctrl{-1} & \targ{} \\
                \lstick{Detector} & \cw & \cw  & \cw & \cw & \cw & \cw
            \end{quantikz}
        };
    \end{tikzpicture}
\end{center}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../MainDocument"
%%% End:
